<p>　　树形 dp 就是在一颗树上做 dp ，其基本思想是由子节点的信息推出父节点的信息。</p>
<p>　　由于树都是一般树，可能不只二叉，所以要用到一般树的“左儿子右兄弟”表示法（详见代码中的 first_child 和 next_sibling）。</p>

<h3>hdu 1520 Anniversary party</h3>
<p>　　最基本的树形 dp 。题目大意是，有一群人之间有上下级关系，在一个 party 中，有直接的上下级关系（即树中的父子关系）的人不能同时出席，每个人都有个 rating ，闻如何选择出席的人，使得所有人的 rating 之和最大。</p>
<p>　　每个节点有两个值，表示这个节点及其子节点所能取得的最大 rating 。max_with 是选择此节点的情况，max_without 不选择此节点。</p>
<p>　　有状态转移方程：</p>
<blockquote>
<div>选择此节点的最大值 = 所有子节点不选择的最大值之和</div>
<div>不选择此节点的最大值 = 每个子节点选择或者不选择的最大值之和</div>
</blockquote>
<p>　　说得太绕了...还是直接看代码吧</p>
<p>　　另外用了一个技巧，由于题目中没说谁是跟，用了一种很 tricky 的方法得到根节点的 id ，详见 root_id</p><!-- 故意的错别字 跟 -->
<p>　　另外我也尝试过非递归的，用了发现非递归反而比递归更耗时，所以就用递归的写法就好。</p>
<p>g++ 31ms</p>
<pre class="brush: cpp; collapse: true">
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define N 6000
#define MAX(a, b) ((a)&gt;(b)?(a):(b))

struct node_t {
	struct node_t *first_child;
	struct node_t *next_sibling;
	int max_with;
	int max_without;
};

struct node_t nodes[N];

void dp(struct node_t *node) {
	struct node_t *child_node = node-&gt;first_child;
	// node-&gt;max_with = node-&gt;rating;
	// node-&gt;max_without = 0;
	while (child_node != NULL) {
		dp(child_node);
		node-&gt;max_with += child_node-&gt;max_without;
		node-&gt;max_without += MAX(child_node-&gt;max_with, child_node-&gt;max_without);
		child_node = child_node-&gt;next_sibling;
	}
}

int getint(char end) {
	int s = 0;
	int ch;
	ch = getchar();
	while (ch != end &amp;&amp; ch != EOF) {
		s = s * 10 + ch - '0';
		ch = getchar();
	}
	return s;
}

int main(int argc, char const *argv[])
{
	int n;
	while (scanf("%d", &amp;n) == 1) {
		getchar(); // ignore a \n
		memset(nodes, 0, sizeof(struct node_t) * n);
		int i;
		for (i = 0; i &lt; n; ++i) {
			// scanf("%d", &amp;nodes[i].max_with);
			nodes[i].max_with = getint('\n');
		}
		int l, k;
		int root_id = (n - 1) * n / 2;
		while(1) {
			// scanf("%d%d", &amp;l, &amp;k);
			l = getint(' ');
			k = getint('\n');
			if (l == 0 &amp;&amp; k == 0) {
				break;
			}
			l--;
			k--;
			/* add the parent-child relation: k - parent, l - child */
			nodes[l].next_sibling = nodes[k].first_child;
			nodes[k].first_child = nodes + l;
			root_id -= l;
		}
		dp(nodes + root_id);
		printf("%d\n", MAX(nodes[root_id].max_with, nodes[root_id].max_without));
	}
	return 0;
}
</pre>

<h3>poj 1463 Strategic game</h3>
<p>　　跟上题基本上是对偶的，不过这题的输入格式比较变态。</p>
<p>gcc 16ms</p>
<pre class="brush: cpp; collapse: true">
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define N 1500
#define MIN(a, b) ((a)&lt;(b)?(a):(b))

struct node_t {
	struct node_t *first_child;
	struct node_t *next_sibling;
	int min_with;
	int min_without;
};

struct node_t nodes[N];

void dp(struct node_t *node) {
	struct node_t *child_node = node-&gt;first_child;
	node-&gt;min_with = 1;
	while (child_node != NULL) {
		dp(child_node);
		node-&gt;min_without += child_node-&gt;min_with;
		node-&gt;min_with += MIN(child_node-&gt;min_with, child_node-&gt;min_without);
		child_node = child_node-&gt;next_sibling;
	}
}

int getint(char end) {
	// static char buf[20];
	// int i = 0;
	int s = 0;
	int ch;
	ch = getchar();
	while (ch != end &amp;&amp; ch != EOF) {
		// buf[i++] = ch;
		s = s * 10 + ch - '0';
		ch = getchar();
	}
	// buf[i] = '\0';
	return s;
}

int getint2(int *out) {
	// static char buf[20];
	// int i = 0;
	register int s = 0;
	register int ch;
	ch = getchar();
	while (ch &lt; '0' || ch &gt; '9') {
		ch = getchar();
	}
	while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') {
		// buf[i++] = ch;
		s = s * 10 + ch - '0';
		ch = getchar();
	}
	// buf[i] = '\0';
	*out = s; // atoi(buf);
	return ch;
}

int main(int argc, char const *argv[])
{
	int n;
	while (scanf("%d", &amp;n) == 1) {
		getchar(); // ignore a \n
		memset(nodes, 0, sizeof(struct node_t) * n);
		int i;
		int root_id;
		for (i = 0; i &lt; n; ++i) {
			int parent_id, num;
			// scanf("%d:(%d)", &amp;parent_id, &amp;num);
			// parent_id = getint(':');
			getint2(&amp;parent_id);
			if (i == 0) {
				root_id = parent_id;
			}
			getchar(); // (
			// num = getint(')');
			getint2(&amp;num);
			// getchar(); // space
			int ch;
			for (num--; num &gt;= 0; num--) {
				int node_id;
				ch = getint2(&amp;node_id);
				// node_id = getint2(' ', '\n');
				// scanf("%d", &amp;node_id);
				nodes[node_id].next_sibling = nodes[parent_id].first_child;
				nodes[parent_id].first_child = nodes + node_id;
			}
			while (ch != '\n') {
				ch = getchar();
			}
		}
		dp(nodes + root_id);
		printf("%d\n", MIN(nodes[root_id].min_with, nodes[root_id].min_without));
	}
	return 0;
}
</pre>

<h3>poj 1947 Rebuilding Roads</h3>
<p>　　这题的递推方法跟前面的有所不同，需要用子树及其兄弟的信息递推。也就是要设 F[i][j] 为：“从节点 i 的子节点及其右边的兄弟节点中选择 j 个节点所需的最小的边切割的数量。”具体的还是看 <a href="http://www.byvoid.com/blog/pku-1947/">Beyond the Void 的解题报告</a>吧，他讲得比我好得多了。</p>
<p>　　这题各种边界条件，各种特殊情况，很恶心。</p>
<p>gcc 16ms</p>
<pre class="brush: cpp; collapse: true">
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;limits.h&gt;

#define N 150

#define MIN(a,b) ((a)&lt;(b)?(a):(b))

struct node_t {
	struct node_t *first_child;
	struct node_t *next_sibling;
	int capacity;
	int min_edge_cut[N+1];
} nodes[N];

int infadd(int a, int b) {
	if (a == INT_MAX || b == INT_MAX) {
		return INT_MAX;
	}
	return a + b;
}

int dp(struct node_t *node, int node_num) {
	if (node-&gt;min_edge_cut[node_num] != -1) {
		return node-&gt;min_edge_cut[node_num]; // calculated
	}

	// case1: not choose node
	int case1_min = INT_MAX;
	if (node-&gt;next_sibling) {
		int ret = dp(node-&gt;next_sibling, node_num);
		case1_min = infadd(ret, 1);
	} else if (node_num == 0) {
		case1_min = 1;
	}

	// case2: choose node
	int case2_min = INT_MAX;
	if (node_num == 0) {
		// impossible, pass
	} else {
		if (node-&gt;first_child == NULL &amp;&amp; node-&gt;next_sibling == NULL) {
			if (node_num == 1) {
				case2_min = 0;
			}
		} else if (node-&gt;first_child == NULL) {
			case2_min = dp(node-&gt;next_sibling, node_num - 1);
		} else if (node-&gt;next_sibling == NULL) {
			case2_min = dp(node-&gt;first_child, node_num - 1);
		} else {
			int k;
			for (k = 0; k &lt; node_num; ++k) {
				int ret = infadd(dp(node-&gt;first_child, k), dp(node-&gt;next_sibling, node_num - 1 - k));
				if (ret &lt; case2_min) {
					case2_min = ret;
				}
			}
		}
	}

	int tmp = MIN(case1_min, case2_min);
	node-&gt;min_edge_cut[node_num] = tmp;
	// printf("node %d provide %d nodes: %d\n", node - nodes + 1, node_num, tmp);
	return tmp;
}

/**
 * init capacity
 */
void init_node(struct node_t *node) {
	struct node_t *child_node = node-&gt;first_child;
	node-&gt;capacity = 1;
	memset(node-&gt;min_edge_cut, -1, sizeof(node-&gt;min_edge_cut));
	while (child_node != NULL) {
		init_node(child_node);
		node-&gt;capacity += child_node-&gt;capacity;
		child_node = child_node-&gt;next_sibling;
	}
}

int main(int argc, char const *argv[])
{
	int n, p;
	scanf("%d%d", &amp;n, &amp;p);
	int i;
	int root_id = (n - 1) * n / 2;
	for (i = 0; i &lt; n-1; ++i) {
		int p, c;
		scanf("%d%d", &amp;p, &amp;c);
		p--; c--;
		nodes[c].next_sibling = nodes[p].first_child;
		nodes[p].first_child = nodes + c;
		root_id -= c;
	}
	init_node(nodes + root_id);
	int min_cut = INT_MAX;
	for (i = 0; i &lt; n; ++i) {
		int ret = (i != root_id);
		if (nodes[i].first_child) {
			ret = infadd(ret, dp(nodes[i].first_child, p - 1));
		} else {
			ret = infadd(ret, p == 1 ? 0 : INT_MAX);
		}
		if (ret &lt; min_cut) {
			min_cut = ret;
		}
	}
	printf("%d\n", min_cut);
	return 0;
}
</pre>

<p>其他树形 dp 题目：</p>
<ul>
<li>hdu 1011 <a href="http://www.cnblogs.com/kuangbin/archive/2012/03/14/2396449.html">Starship Troopers</a></li>
<li>poj 3345 <a href="http://blog.csdn.net/waitfor_/article/details/7235386">Bribing FIPA</a></li>
<li>hdu 2196 <a href="http://blog.csdn.net/waitfor_/article/details/7182602">Computer</a></li>
</ul>
