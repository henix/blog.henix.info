<p>　　C++ 的 vector 是有多蛋疼啊！比如现在有一个 vector&lt;int&gt; ，我要删除所有值为 0 的元素。</p>
<p>　　一种 naive 的想法是：</p>
<pre class="brush: cpp">
vector&lt;int&gt;::iterator it = ar.begin();
for (; it != ar.end(); it++) {
	if (*it == 0) {
		ar.erase(it);
	}
}
</pre>
<p>　　当然，这是错的，因为 <a href="http://www.cplusplus.com/forum/general/10625/">erase 会使 iterator 失效</a>。</p>
<p>　　根据 erase 的返回值是一个新的 iterator ，我得出了方案 2 ：</p>
<pre class="brush: cpp">
vector&lt;int&gt;::iterator it = ar.begin();
for (; it != ar.end(); it++) {
	if (*it == 0) {
		it = ar.erase(it);
	}
}
</pre>
<p>　　事实上，虽然这很接近正确答案，但这也是错的。erase 返回的就是下一个 iterator ，所以不需要再 ++ 了。正解：</p>
<pre class="brush: cpp">
vector&lt;int&gt;::iterator it = ar.begin();
while (it != ar.end()) {
	if (*it == 0) {
		it = ar.erase(it);
	} else {
		it++;
	}
}
</pre>
<p>　　最后我发现还有 remove_if 这种东西：</p>
<pre class="brush: cpp">
#include &lt;functional&gt;

vector&lt;int&gt;::iterator pend = remove_if(pbegin, ar.end(), bind1st(equal_to&lt;int&gt;(), 0));
ar.erase(pend, ar.end());
</pre>
<p>　　remove_if 会把后面的调整到前面正确的位置上去，但不会删除。再用 erase 删除最后的无用元素。</p>
<p>　　又是 equal_to 仿函数，又是 bind1st 的柯里化……C++ 的函数式特性很不错，但 vector 真的很蛋疼。</p>
