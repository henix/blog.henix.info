<p>　　<a href="http://en.wikipedia.org/wiki/Longest_increasing_subsequence">最长上升子序列</a>（Longest increasing subsequence, LIS）是个经典的动态规划问题，用动态规划可以在 \(O(n^2)\) 的时间内解决。</p>
<p>　　问题描述参见 <a href="http://poj.org/problem?id=2533">POJ 2533</a> 。</p>
<p>　　但还有另外一种利用决策的单调性的算法，可以在 \(O(n\log n)\) 的时间解决。</p>
<p>　　设 min[i] 为长度为 i 的最长子序列的最后一个元素最小可以是多少。每次将原序列的一个元素 a 插入到 min 数组中，并更新数组 min ，每次只需找到 min 中第一个比 a 大的数，并用 a 替换那个数。在查找的时候可以用二分查找，于是时间复杂度是 \(O(n\log n)\) 。</p>
<p>　　代码：</p>
<pre class="brush: cpp">
#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

int main(int argc, char *argv[])
{
	int n;
	scanf("%d", &amp;n);
	int ar[n];
	int i;
	for (i = 0; i &lt; n; i++) {
		scanf("%d", ar + i);
	}
	int min[n];
	int len = 0;
	for (i = 0; i &lt; n; i++) {
		/* insert ar[i] into min */
		int l = 0, r = len;
		int mid;
		bool found = false;
		while (l &lt; r) {
			mid = (l + r) / 2;
			if (ar[i] &lt; min[mid]) {
				r = mid;
			} else if (ar[i] &gt; min[mid]) {
				l = mid + 1;
			} else {
				found = true;
				break;
			}
		}
		if (! found) {
			min[r] = ar[i];
			if (r == len) {
				len++;
			}
		}
	}
	printf("%d\n", len);
	return 0;
}
</pre>
#{include: 'mathjax.seg.htm' }#
