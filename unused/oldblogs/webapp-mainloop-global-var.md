　　web 应用写起来纠结的根本原因是，我们自己没有 main loop 。

　　没有 main loop ，代码必然会被分隔得七零八落。而且，各个变量的生命周期变得不明显，或者说，生命周期的控制权不在你手上。

　　考虑一个简单的程序，它可以执行两种命令：1. 创建索引 2. 在索引中搜索某个关键词

　　可以表达为以下两条命令：

* createIndex() // 这里信息的来源（比如数据库）和索引的位置是由后台配置的，用户不管（不出现的参数中）
* search(keywords: String) // 用户需要输入一个关键字

　　如果我们把它实现成一个控制台程序，将是：

```
main() {
  初始化一些全局变量（比如索引存放在哪里，连接信息源） // 注意这里！
  while(true) {
    命令 = 读取用户输入
    if (命令 == "createIndex") {
      创建索引
    } else if (命令 == "search") {
      搜索，返回结果
    } else if (命令 == "exit") {
      break
    }
  }
  执行清理，比如如果信息源是数据库，那么需要关闭数据库连接。如果索引存放在文件系统，那么需要关闭文件描述符。
}
```

　　注意到，全局变量可以放到主循环之前进行初始化。又注意到，这里所谓“全局变量”其实不是全局变量，只是 main 函数的局部变量。这些变量的生命周期是很明显的：随着 main 函数的退出而被销毁。

　　如果改成 web 程序又如何呢？

```
声明全局变量

init {
  初始化全局变量
}

deinit {
   执行清理
}

"/createIndex" get {
   创建索引
}

"/search" get {
   搜索，返回结果
}
```

　　由于控制流不在自己手上，故不得不采用这种回调函数的设计，这让我们想起了什么？有没有想到 nodejs 的异步回调，以及回调金字塔？同样是会把代码分割得七零八落。

　　由于代码被分割，为了变量在所有函数中可见，这次不得不采用真正的全局变量。但由于自己没有 main loop ，这些全局变量在何时初始化、何时被销毁变得模糊不定。也就是生命周期变得不那么明显。

　　有没有又联想到什么？GUI 类程序是不是也是这种情况？

> 隐藏 main loop 定理：如果你想实现一个可扩展的 API ，但是整个系统的 main loop 被你隐藏了，那么在你的 API 之上编写的程序就具有 web 或者 GUI 程序一样的特点。

　　目前我能找到的最好的 word-around：实现成一个类，然后声明一个全局对象：

```
class App {
  // 一些类成员，各种公共资源，等价于前面的方案中的全局变量
  App() {
    // 初始化类成员
  }
  createIndex();
  search();
  ~App {
    // 执行清理
  }
}

lazy val App app; // 一个全局实例，这里使用了 scala 的 lazy val

init {
  app = new App()
}

deinit {
  app.close()
}

"/createIndex" get {
  app.createIndex()
}

"/search" get {
  app.search()
}
```

　　这个方案把全局变量变成了类成员，虽然最终还是要声明该类的一个全局实例。

　　Java 不像 C++ 有析构函数，而 finalize 函数也不保证会被 gc 调用，所以在清理资源这方面要麻烦一点。我一般是加上一个 close() 函数，然后在 `ServletContextListener.contextDestroyed`（如果该对象需要在几个 servlet 间共用）或者在 `HttpServlet.destroy`（如果该对象只在一个 servlet 中使用）函数中调用 close 。
